name: Build Android APK
on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python 3.9
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    # ✅ 완전한 클린 빌드
    - name: Complete clean build
      run: |
        echo "=== 🧹 Completely cleaning build environment ==="
        rm -rf .buildozer bin build android/build android/.gradle
        rm -rf ~/.buildozer ~/.gradle ~/.android
        echo "✅ 모든 캐시 제거 완료"

    # ✅ Java 17 세팅
    - name: Set up Java 17 for buildozer
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    # ✅ 시스템 종속 패키지 설치
    - name: Install system dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y \
          git zip unzip autoconf libtool pkg-config \
          zlib1g-dev libncurses5-dev libncursesw5-dev libtinfo5 cmake \
          libffi-dev libssl-dev build-essential libsqlite3-dev sqlite3 \
          bzip2 libbz2-dev libreadline-dev llvm \
          xz-utils tk-dev libxml2-dev libxmlsec1-dev liblzma-dev \
          libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev \
          libportmidi-dev libswscale-dev libavformat-dev libavcodec-dev \
          libfreetype6-dev libpng-dev libjpeg-dev aapt

    # ✅ 파이썬 의존성 설치
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install --upgrade setuptools wheel
        pip install Cython==0.29.33
        pip install buildozer==1.4.0

    # ✅ 환경 변수 설정
    - name: Set environment variables
      run: |
        echo "P4A_NUM_PROCS=1" >> $GITHUB_ENV
        echo "GRADLE_OPTS=-Dorg.gradle.daemon=false -Dorg.gradle.jvmargs='-Xmx3072m -XX:MaxMetaspaceSize=768m' -Dorg.gradle.parallel=false" >> $GITHUB_ENV
        echo "P4A_GRADLE_OPTS=--stacktrace --info" >> $GITHUB_ENV

    # ✅ APK 수정 도구 설치
    - name: Install APK modification tools
      run: |
        echo "=== 🛠️ APK 수정 도구 설치 ==="
        
        # Android SDK 명령줄 도구 설치
        echo "📥 Android SDK 명령줄 도구 다운로드..."
        mkdir -p ~/android-sdk
        cd ~/android-sdk
        
        wget -q https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
        unzip -q commandlinetools-linux-11076708_latest.zip
        mkdir -p cmdline-tools/latest
        mv cmdline-tools/* cmdline-tools/latest/ 2>/dev/null || true
        
        # 환경 변수 설정
        export ANDROID_SDK_ROOT=~/android-sdk
        export PATH=$PATH:$ANDROID_SDK_ROOT/cmdline-tools/latest/bin:$ANDROID_SDK_ROOT/build-tools/34.0.0
        echo "ANDROID_SDK_ROOT=~/android-sdk" >> $GITHUB_ENV
        echo "~/android-sdk/cmdline-tools/latest/bin" >> $GITHUB_PATH
        echo "~/android-sdk/build-tools/34.0.0" >> $GITHUB_PATH
        
        # SDK 라이센스 자동 동의
        yes | sdkmanager --licenses || true
        
        # build-tools 최신 버전 설치
        echo "🔧 Android Build Tools 설치..."
        sdkmanager "build-tools;34.0.0" "platform-tools"
        
        # apktool 최신 버전 다운로드 및 설치
        echo "📥 apktool 다운로드..."
        cd ~
        wget -q https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool
        wget -q https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_2.9.3.jar
        
        chmod +x apktool
        sudo mv apktool /usr/local/bin/
        sudo mv apktool_2.9.3.jar /usr/local/bin/apktool.jar
        
        # 도구 버전 확인
        echo "✅ 설치된 도구 버전:"
        apktool --version || echo "apktool 버전 확인 실패"
        ls -la ~/android-sdk/build-tools/34.0.0/
        
        echo "✅ 모든 도구 설치 완료"

    # ✅ 빌드 수행
    - name: Build APK with buildozer
      run: |
        echo "=== 🔨 Buildozer APK 빌드 ==="
        buildozer android debug --verbose > build_full.log 2>&1 || BUILD_FAILED=true
        if [ "$BUILD_FAILED" = "true" ]; then
          echo "❌ 빌드 실패!"
          echo "=== 빌드 로그 마지막 100줄 ==="
          tail -100 build_full.log
          exit 1
        else
          echo "✅ 빌드 성공!"
        fi

    # ✅ APK 파일 찾기 및 검증
    - name: Find and verify APK
      run: |
        echo "=== 🔍 APK 파일 찾기 및 검증 ==="
        
        # APK 파일 자동 탐지
        POSSIBLE_APKS=(
          "./bin/doublecheck-0.1-arm64-v8a-debug.apk"
          "./bin/*.apk"
          ".buildozer/android/platform/build-arm64-v8a/dists/doublecheck/build/outputs/apk/debug/*.apk"
        )
        
        FOUND_APK=""
        for apk_pattern in "${POSSIBLE_APKS[@]}"; do
          for apk_file in $apk_pattern; do
            if [ -f "$apk_file" ]; then
              FOUND_APK="$apk_file"
              echo "✅ APK 발견: $FOUND_APK"
              break 2
            fi
          done
        done
        
        if [ -z "$FOUND_APK" ]; then
          FOUND_APK=$(find . -name "*debug*.apk" -type f | head -1)
          if [ -n "$FOUND_APK" ]; then
            echo "✅ 전체 검색으로 APK 발견: $FOUND_APK"
          else
            echo "❌ APK 파일을 찾을 수 없음"
            exit 1
          fi
        fi
        
        echo "ORIGINAL_APK=$FOUND_APK" >> $GITHUB_ENV
        echo "📊 APK 크기: $(du -h "$FOUND_APK" | cut -f1)"
        
        # 원본 APK 유효성 검사
        if aapt dump badging "$FOUND_APK" >/dev/null 2>&1; then
          echo "✅ 원본 APK 구조 유효"
        else
          echo "❌ 원본 APK 구조 오류"
          exit 1
        fi

    # ✅ APK 수정 (AlarmReceiver 추가)
    - name: Modify APK to add AlarmReceiver
      run: |
        echo "=== 🔧 APK 수정 (AlarmReceiver 추가) ==="
        
        if [ -z "${ORIGINAL_APK:-}" ] || [ ! -f "$ORIGINAL_APK" ]; then
          echo "❌ 원본 APK 없음"
          exit 1
        fi
        
        echo "🎯 대상 APK: $ORIGINAL_APK"
        
        # 백업 생성
        cp "$ORIGINAL_APK" original_backup.apk
        echo "✅ 원본 백업 완료"
        
        # 작업 공간 정리
        rm -rf decoded_apk_clean
        
        # APK 디컴파일
        echo "📦 APK 디컴파일..."
        if apktool d "$ORIGINAL_APK" -o decoded_apk_clean --force --no-debug-info; then
          echo "✅ APK 디컴파일 성공"
        else
          echo "❌ APK 디컴파일 실패"
          exit 1
        fi
        
        # AndroidManifest.xml 수정
        MANIFEST="decoded_apk_clean/AndroidManifest.xml"
        cp "$MANIFEST" "${MANIFEST}.backup"
        
        echo "🔍 현재 매니페스트 상태:"
        echo "- activity: $(grep -c '<activity' "$MANIFEST" 2>/dev/null || echo "0")개"
        echo "- receiver: $(grep -c '<receiver' "$MANIFEST" 2>/dev/null || echo "0")개"
        echo "- service: $(grep -c '<service' "$MANIFEST" 2>/dev/null || echo "0")개"
        
        if grep -q "AlarmReceiver" "$MANIFEST"; then
          echo "⚠️ AlarmReceiver 이미 존재함 - 수정하지 않음"
        else
          echo "➕ AlarmReceiver 추가 중..."
          
          if grep -q "</application>" "$MANIFEST"; then
            sed -i '/<\/application>/i\        <receiver android:name="org.kivy.skkutimetable.doublecheck.AlarmReceiver" android:enabled="true" android:exported="true">\
            <intent-filter>\
                <action android:name="android.intent.action.BOOT_COMPLETED" />\
            </intent-filter>\
        </receiver>' "$MANIFEST"
            
            echo "✅ AlarmReceiver 추가 완료"
          else
            echo "❌ </application> 태그 없음"
            exit 1
          fi
        fi
        
        # 수정 결과 검증
        if grep -q "AlarmReceiver" "$MANIFEST"; then
          echo "✅ AlarmReceiver 확인됨"
          echo "📊 수정 후 receiver 개수: $(grep -c '<receiver' "$MANIFEST" 2>/dev/null || echo "0")"
        else
          echo "❌ AlarmReceiver 추가 실패"
          exit 1
        fi
        
        # XML 문법 검증
        if command -v xmllint >/dev/null 2>&1; then
          if xmllint --noout "$MANIFEST" 2>/dev/null; then
            echo "✅ XML 문법 유효"
          else
            echo "❌ XML 문법 오류 - 백업에서 복원"
            cp "${MANIFEST}.backup" "$MANIFEST"
            exit 1
          fi
        fi

    # ✅ 방법 1: aapt2 사용한 정교한 APK 수정
    - name: Method 1 - Precise APK modification with aapt2
      run: |
        echo "=== 🔧 방법 1: aapt2를 사용한 정교한 APK 수정 ==="
        
        if [ -f "${ORIGINAL_APK:-}" ]; then
          echo "🎯 aapt2로 정교하게 수정해보겠습니다..."
          
          # aapt2 설치 확인
          if command -v aapt2 >/dev/null 2>&1; then
            echo "✅ aapt2 이미 설치됨"
          else
            echo "📥 aapt2 설치 중..."
            # Android SDK의 aapt2 사용
            AAPT2_PATH="$HOME/android-sdk/build-tools/34.0.0/aapt2"
            if [ -f "$AAPT2_PATH" ]; then
              echo "✅ aapt2 발견: $AAPT2_PATH"
              sudo ln -sf "$AAPT2_PATH" /usr/local/bin/aapt2 || true
            else
              echo "❌ aapt2 없음 - 설치 시도"
              echo "aapt2 설치를 위해 build-tools 재설치..."
            fi
          fi
          
          # 1단계: 원본 APK 분해 (aapt2 방식)
          echo "📦 1단계: APK 리소스 추출 (aapt2)..."
          mkdir -p aapt2_work
          cd aapt2_work
          
          # APK를 ZIP으로 처리해서 파일들 추출
          cp "../$ORIGINAL_APK" original.apk
          unzip -q original.apk
          
          echo "✅ APK 파일 추출 완료"
          ls -la | head -10
          
          # 2단계: 매니페스트를 텍스트로 변환 (aapt2 dump)
          echo "📄 2단계: 매니페스트 텍스트 변환..."
          if aapt2 dump badging original.apk > package_info.txt 2>&1; then
            echo "✅ aapt2 dump 성공"
            head -5 package_info.txt
          else
            echo "❌ aapt2 dump 실패"
            cat package_info.txt | head -5
          fi
          
          # aapt로 매니페스트 XML 형태로 추출
          echo "📋 매니페스트 XML 추출..."
          if aapt dump xmltree original.apk AndroidManifest.xml > manifest_readable.xml 2>&1; then
            echo "✅ 매니페스트 XML 추출 성공"
            echo "현재 receiver 개수: $(grep -c "receiver" manifest_readable.xml || echo "0")"
          else
            echo "❌ 매니페스트 XML 추출 실패"
          fi
          
          # 3단계: 바이너리 매니페스트 직접 분석
          echo "🔍 3단계: 바이너리 매니페스트 분석..."
          echo "매니페스트 파일 정보:"
          ls -la AndroidManifest.xml
          echo "매니페스트 헥스 덤프 (처음 64바이트):"
          hexdump -C AndroidManifest.xml | head -4
          
          cd ..
          echo "aapt2 방법 1단계 완료"
        fi

    # ✅ 방법 2: 바이너리 헥스 에디터 방식
    - name: Method 2 - Binary hex editor approach
      run: |
        echo "=== 🔬 방법 2: 바이너리 헥스 에디터 방식 ==="
        
        if [ -f "${ORIGINAL_APK:-}" ]; then
          echo "🎯 매니페스트 바이너리를 직접 분석하고 수정해보겠습니다..."
          
          mkdir -p hex_work
          cd hex_work
          
          # APK에서 매니페스트 추출
          unzip -j "../$ORIGINAL_APK" AndroidManifest.xml
          
          if [ -f "AndroidManifest.xml" ]; then
            echo "✅ 매니페스트 추출 완료"
            
            # 바이너리 분석
            echo "📊 매니페스트 바이너리 정보:"
            echo "크기: $(wc -c < AndroidManifest.xml) bytes"
            echo "파일 타입: $(file AndroidManifest.xml)"
            
            # 문자열 테이블 찾기
            echo "🔍 매니페스트 내 문자열 검색:"
            strings AndroidManifest.xml | grep -E "(receiver|activity|AlarmReceiver)" | head -10 || echo "관련 문자열 없음"
            
            # receiver 패턴 검색
            echo "📡 receiver 관련 바이너리 패턴 검색:"
            xxd AndroidManifest.xml | grep -i "receiver" || echo "receiver 바이너리 패턴 없음"
            
            # application 태그 위치 찾기
            echo "📱 application 태그 위치 검색:"
            xxd AndroidManifest.xml | grep -i "application" | head -3 || echo "application 태그 찾기 실패"
            
            # 매니페스트 구조 분석을 위한 바이너리 덤프
            echo "🗂️ 매니페스트 구조 분석:"
            echo "첫 32바이트 (헤더):"
            xxd AndroidManifest.xml | head -2
            echo "마지막 32바이트:"
            xxd AndroidManifest.xml | tail -2
            
            # 백업 생성
            cp AndroidManifest.xml AndroidManifest.xml.backup
            echo "✅ 매니페스트 백업 완료"
            
          else
            echo "❌ 매니페스트 추출 실패"
          fi
          
          cd ..
        fi

    # ✅ 방법 3: baksmali/smali (DEX 레벨 수정)
    - name: Method 3 - baksmali/smali DEX level modification
      run: |
        echo "=== ⚙️ 방법 3: baksmali/smali DEX 레벨 수정 ==="
        
        if [ -f "${ORIGINAL_APK:-}" ]; then
          echo "🎯 DEX 파일 레벨에서 수정을 시도해보겠습니다..."
          
          # baksmali/smali 도구 다운로드
          echo "📥 baksmali/smali 도구 다운로드..."
          wget -q https://bitbucket.org/JesusFreke/smali/downloads/baksmali-2.5.2.jar -O baksmali.jar
          wget -q https://bitbucket.org/JesusFreke/smali/downloads/smali-2.5.2.jar -O smali.jar
          
          if [ -f "baksmali.jar" ] && [ -f "smali.jar" ]; then
            echo "✅ baksmali/smali 다운로드 완료"
            
            mkdir -p dex_work
            cd dex_work
            
            # APK에서 classes.dex 추출
            unzip -j "../$ORIGINAL_APK" "classes*.dex"
            
            if [ -f "classes.dex" ]; then
              echo "✅ classes.dex 추출 완료"
              echo "DEX 파일 크기: $(du -h classes.dex | cut -f1)"
              
              # DEX를 smali 코드로 디컴파일
              echo "🔧 DEX → smali 디컴파일..."
              java -jar ../baksmali.jar disassemble classes.dex -o smali_out
              
              if [ -d "smali_out" ]; then
                echo "✅ smali 디컴파일 성공"
                echo "생성된 smali 파일 개수: $(find smali_out -name "*.smali" | wc -l)"
                
                # 메인 액티비티 찾기
                echo "🔍 메인 액티비티 파일 찾기:"
                find smali_out -name "*Activity*.smali" | head -5
                
                # PythonActivity 찾기
                PYTHON_ACTIVITY=$(find smali_out -name "*PythonActivity*.smali" | head -1)
                if [ -n "$PYTHON_ACTIVITY" ]; then
                  echo "✅ PythonActivity 발견: $PYTHON_ACTIVITY"
                  echo "파일 크기: $(wc -l < "$PYTHON_ACTIVITY") 줄"
                  
                  # Activity 내용 일부 확인
                  echo "📄 PythonActivity 일부 내용:"
                  head -20 "$PYTHON_ACTIVITY"
                  
                else
                  echo "❌ PythonActivity 없음"
                fi
                
                # BroadcastReceiver 클래스 추가 준비
                echo "📡 BroadcastReceiver 클래스 생성 준비..."
                mkdir -p smali_out/org/kivy/skkutimetable/doublecheck
                
                # 간단한 AlarmReceiver smali 코드 생성
                cat > smali_out/org/kivy/skkutimetable/doublecheck/AlarmReceiver.smali << 'EOF'
.class public Lorg/kivy/skkutimetable/doublecheck/AlarmReceiver;
.super Landroid/content/BroadcastReceiver;

.method public constructor <init>()V
    .locals 0
    invoke-direct {p0}, Landroid/content/BroadcastReceiver;-><init>()V
    return-void
.end method

.method public onReceive(Landroid/content/Context;Landroid/content/Intent;)V
    .locals 2
    const-string v0, "AlarmReceiver"
    const-string v1, "Boot completed - alarm restore needed"
    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I
    return-void
.end method
EOF
                
                echo "✅ AlarmReceiver.smali 생성 완료"
                
                # smali → DEX 재컴파일
                echo "🔨 smali → DEX 재컴파일..."
                java -jar ../smali.jar assemble smali_out -o classes_modified.dex
                
                if [ -f "classes_modified.dex" ]; then
                  echo "✅ DEX 재컴파일 성공"
                  echo "수정된 DEX 크기: $(du -h classes_modified.dex | cut -f1)"
                else
                  echo "❌ DEX 재컴파일 실패"
                fi
                
              else
                echo "❌ smali 디컴파일 실패"
              fi
              
            else
              echo "❌ classes.dex 추출 실패"
            fi
            
            cd ..
          else
            echo "❌ baksmali/smali 다운로드 실패"
          fi
        fi

    # ✅ 방법 4: APK 합성 (파일 교체)
    - name: Method 4 - APK synthesis (file replacement)
      run: |
        echo "=== 🔄 방법 4: APK 합성 (파일 교체) ==="
        
        if [ -f "${ORIGINAL_APK:-}" ]; then
          echo "🎯 ZIP 레벨에서 파일을 교체해보겠습니다..."
          
          mkdir -p synthesis_work
          cd synthesis_work
          
          # 1. 원본 APK 복사
          cp "../$ORIGINAL_APK" base.apk
          
          # 2. 간단한 매니페스트 생성 (텍스트)
          echo "📝 수정된 매니페스트 생성..."
          cat > AndroidManifest_text.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.kivy.skkutimetable.doublecheck"
    android:versionCode="10211"
    android:versionName="0.1">
    
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.VIBRATE" />
    
    <application android:label="DoubleCheck" android:icon="@mipmap/icon">
        <activity android:name="org.kivy.android.PythonActivity"
                  android:label="DoubleCheck"
                  android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <service android:name="org.kivy.android.PythonService" android:process=":pythonservice" />
        
        <receiver android:name="org.kivy.skkutimetable.doublecheck.AlarmReceiver"
                  android:enabled="true"
                  android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
        
    </application>
</manifest>
EOF
          
          # 3. aapt를 사용해서 텍스트 매니페스트를 바이너리로 변환
          echo "🔄 텍스트 매니페스트 → 바이너리 변환..."
          
          # 임시 리소스 디렉토리 생성
          mkdir -p temp_resources/res/values
          echo '<?xml version="1.0" encoding="utf-8"?><resources></resources>' > temp_resources/res/values/strings.xml
          
          # aapt로 바이너리 매니페스트 생성 시도
          if aapt package -f -M AndroidManifest_text.xml -S temp_resources/res -I "$ANDROID_HOME/platforms/android-33/android.jar" -F temp.apk 2>/dev/null; then
            echo "✅ 바이너리 매니페스트 생성 성공"
            
            # 생성된 매니페스트 추출
            unzip -j temp.apk AndroidManifest.xml -d .
            if [ -f "AndroidManifest.xml" ]; then
              echo "✅ 새 매니페스트 추출 완료"
              echo "새 매니페스트 크기: $(wc -c < AndroidManifest.xml) bytes"
              
              # 4. 원본 APK에 새 매니페스트 삽입
              echo "🔧 원본 APK에 새 매니페스트 삽입..."
              zip base.apk AndroidManifest.xml
              
              # 5. 결과 APK 검증
              echo "✅ 합성 APK 생성 완료"
              mv base.apk synthesis_fixed.apk
              
              # 검증
              if aapt dump badging synthesis_fixed.apk >/dev/null 2>&1; then
                echo "✅ 합성 APK 구조 유효"
                echo "📋 합성 APK 정보:"
                aapt dump badging synthesis_fixed.apk | head -5
              else
                echo "❌ 합성 APK 구조 오류"
              fi
              
            else
              echo "❌ 새 매니페스트 추출 실패"
            fi
          else
            echo "❌ 바이너리 매니페스트 생성 실패"
          fi
          
          cd ..
        fi

    # ✅ 방법 5: Android Studio 프로젝트 변환
    - name: Method 5 - Convert to Android Studio project
      run: |
        echo "=== 🏗️ 방법 5: Android Studio 프로젝트 변환 ==="
        
        if [ -f "${ORIGINAL_APK:-}" ]; then
          echo "🎯 APK → Android Studio 프로젝트 변환 시도..."
          
          mkdir -p studio_work
          cd studio_work
          
          # jadx 도구 다운로드 (APK → Java 소스 변환)
          echo "📥 jadx 도구 다운로드..."
          wget -q https://github.com/skylot/jadx/releases/download/v1.4.7/jadx-1.4.7.zip -O jadx.zip
          
          if [ -f "jadx.zip" ]; then
            unzip -q jadx.zip
            chmod +x jadx-1.4.7/bin/jadx
            
            echo "✅ jadx 설치 완료"
            
            # APK를 Java 프로젝트로 변환
            echo "🔄 APK → Java 소스 변환..."
            ./jadx-1.4.7/bin/jadx "../$ORIGINAL_APK" -d java_project
            
            if [ -d "java_project" ]; then
              echo "✅ Java 프로젝트 변환 성공"
              
              # 매니페스트 확인
              if [ -f "java_project/resources/AndroidManifest.xml" ]; then
                echo "✅ 매니페스트 발견"
                echo "📄 현재 매니페스트 내용:"
                head -20 java_project/resources/AndroidManifest.xml
                
                # 매니페스트에 receiver 추가
                echo "📡 receiver 추가 중..."
                cp java_project/resources/AndroidManifest.xml java_project/resources/AndroidManifest.xml.backup
                
                # receiver 태그 삽입
                sed -i '/<\/application>/i\        <receiver android:name="org.kivy.skkutimetable.doublecheck.AlarmReceiver" android:enabled="true" android:exported="true">\
            <intent-filter>\
                <action android:name="android.intent.action.BOOT_COMPLETED" />\
            </intent-filter>\
        </receiver>' java_project/resources/AndroidManifest.xml
                
                echo "✅ 매니페스트 수정 완료"
                echo "📋 수정된 매니페스트:"
                grep -A 10 -B 5 "AlarmReceiver" java_project/resources/AndroidManifest.xml || echo "추가 실패"
                
              else
                echo "❌ 매니페스트 없음"
              fi
              
              # 프로젝트 구조 확인
              echo "📁 프로젝트 구조:"
              find java_project -type f -name "*.xml" | head -10
              
            else
              echo "❌ Java 프로젝트 변환 실패"
            fi
          else
            echo "❌ jadx 다운로드 실패"
          fi
          
          cd ..
        fi

    # ✅ 모든 방법 결과 비교
    - name: Compare all methods results
      run: |
        echo "=== 📊 모든 방법 결과 비교 ==="
        
        echo "🎯 생성된 APK 파일들:"
        find . -name "*.apk" -exec echo "{}:" \; -exec du -h {} \; 2>/dev/null || echo "APK 파일 없음"
        
        echo ""
        echo "📋 각 방법별 성공/실패 상태:"
        
        # 방법 1: aapt2
        if [ -d "aapt2_work" ]; then
          echo "✅ 방법 1 (aapt2): 시도됨"
        else
          echo "❌ 방법 1 (aapt2): 실패"
        fi
        
        # 방법 2: 헥스 에디터
        if [ -f "hex_work/AndroidManifest.xml" ]; then
          echo "✅ 방법 2 (헥스): 매니페스트 추출됨"
        else
          echo "❌ 방법 2 (헥스): 실패"
        fi
        
        # 방법 3: baksmali
        if [ -f "dex_work/classes_modified.dex" ]; then
          echo "✅ 방법 3 (baksmali): DEX 수정됨"
        else
          echo "❌ 방법 3 (baksmali): 실패"
        fi
        
        # 방법 4: 합성
        if [ -f "synthesis_work/synthesis_fixed.apk" ]; then
          echo "✅ 방법 4 (합성): APK 생성됨"
        else
          echo "❌ 방법 4 (합성): 실패"
        fi
        
        # 방법 5: Studio
        if [ -f "studio_work/java_project/resources/AndroidManifest.xml" ]; then
          echo "✅ 방법 5 (Studio): 프로젝트 변환됨"
        else
          echo "❌ 방법 5 (Studio): 실패"
        fi
        
        echo ""
        echo "💡 다음 단계: 가장 성공한 방법으로 최종 APK 생성"✅ 권한 섹션 추가 완료"
          fi
          
          # 수정 결과 확인
          echo "📋 수정된 권한 설정:"
          grep -A 2 -B 2 "android.permissions" buildozer.spec
          
          echo ""
          echo "💡 다음 단계:"
          echo "1. 이 buildozer.spec을 사용해서 클린 빌드"
          echo "2. Python 코드에 동적 receiver 등록 추가"
          echo "3. APK 수정은 포기하고 소스 레벨에서 해결"
          
        else
          echo "❌ buildozer.spec 파일 없음"
          echo "🔍 현재 디렉토리 확인:"
          ls -la | head -10
        fi

    # ✅ 왜 apktool이 실패하는지 근본 원인 분석
    - name: Root cause analysis of apktool failure
      run: |
        echo "=== 🔬 apktool 실패 근본 원인 분석 ==="
        
        echo "🎯 apktool이 실패하는 이유들:"
        echo ""
        echo "1. 바이너리 XML 인코딩 문제:"
        echo "   - Android는 매니페스트를 바이너리 XML로 압축함"
        echo "   - apktool이 이를 텍스트로 변환 후 다시 바이너리로 변환"
        echo "   - 이 과정에서 미묘한 인코딩 차이 발생"
        echo ""
        echo "2. 리소스 테이블 손상:"
        echo "   - resources.arsc 파일이 망가짐"
        echo "   - 아이콘 등 리소스 매핑이 깨짐"
        echo ""
        echo "3. 압축 방식 차이:"
        echo "   - 원본: deflate 압축"
        echo "   - apktool 리빌드: store (무압축) 또는 다른 압축"
        echo ""
        echo "4. 서명 체인 문제:"
        echo "   - 원본과 다른 서명 방식"
        echo "   - zipalign 순서 문제"
        echo ""
        echo "💡 결론:"
        echo "APK 후처리 방식은 본질적으로 불안정함"
        echo "소스 레벨(buildozer.spec + Python 코드)에서 해결하는 게 정답!"
        echo ""
        echo "🎯 최종 권장사항:"
        echo "1. buildozer.spec에 RECEIVE_BOOT_COMPLETED 권한 추가"
        echo "2. Python main.py에 동적 BroadcastReceiver 등록"
        echo "3. APK 직접 수정은 포기"
        echo ""
        echo "이게 가장 안전하고 확실한 방법입니다! 🚀"

    # ✅ 최종 APK 검증
    - name: Final APK validation
      run: |
        echo "=== 🎯 최종 APK 검증 ==="
        
        APK_TO_TEST="final_doublecheck_fixed.apk"
        
        if [ ! -f "$APK_TO_TEST" ]; then
          echo "❌ 최종 APK 없음"
          exit 1
        fi
        
        echo "📱 최종 APK 정보:"
        echo "파일명: $APK_TO_TEST"
        echo "크기: $(du -h "$APK_TO_TEST" | cut -f1)"
        
        # APK 구조 검증
        echo "🔍 APK 구조 검증..."
        if aapt dump badging "$APK_TO_TEST" > apk_info.txt 2>&1; then
          echo "✅ APK 구조 유효"
          
          # 패키지 정보 출력
          echo "📦 패키지 정보:"
          grep "package:" apk_info.txt | head -3
          grep "application:" apk_info.txt | head -1
          grep "launchable-activity:" apk_info.txt | head -1
          
        else
          echo "❌ APK 구조 오류"
          cat apk_info.txt
          exit 1
        fi
        
        # 서명 검증
        echo "🔏 서명 검증..."
        if jarsigner -verify "$APK_TO_TEST" 2>/dev/null; then
          echo "✅ 서명 유효"
        else
          echo "❌ 서명 무효"
          jarsigner -verify -verbose "$APK_TO_TEST" || true
        fi
        
        # zipalign 검증
        ZIPALIGN_PATH="$HOME/android-sdk/build-tools/34.0.0/zipalign"
        if [ -f "$ZIPALIGN_PATH" ]; then
          if $ZIPALIGN_PATH -c 4 "$APK_TO_TEST" >/dev/null 2>&1; then
            echo "✅ APK 정렬 유효"
          else
            echo "⚠️ APK 정렬 문제"
          fi
        fi
        
        # 매니페스트 검증
        echo "📄 매니페스트 검증..."
        rm -rf final_verification
        apktool d "$APK_TO_TEST" -o final_verification --force >/dev/null 2>&1
        
        if [ -f "final_verification/AndroidManifest.xml" ]; then
          FINAL_MANIFEST="final_verification/AndroidManifest.xml"
          
          echo "🔍 매니페스트 정보:"
          PACKAGE_NAME=$(grep 'package=' "$FINAL_MANIFEST" | head -1 | sed 's/.*package="//;s/".*//')
          echo "- package: $PACKAGE_NAME"
          echo "- activity: $(grep -c '<activity' "$FINAL_MANIFEST" 2>/dev/null || echo "0")개"
          echo "- receiver: $(grep -c '<receiver' "$FINAL_MANIFEST" 2>/dev/null || echo "0")개"
          echo "- service: $(grep -c '<service' "$FINAL_MANIFEST" 2>/dev/null || echo "0")개"
          
          if grep -q "AlarmReceiver" "$FINAL_MANIFEST"; then
            echo "✅ AlarmReceiver 정상 포함!"
          else
            echo "❌ AlarmReceiver 없음"
          fi
          
          # MAIN 액티비티 확인
          if grep -A 10 'android.intent.action.MAIN' "$FINAL_MANIFEST" | grep -q 'android:name'; then
            echo "✅ MAIN 액티비티 존재"
            MAIN_ACTIVITY=$(grep -B 5 -A 5 'android.intent.action.MAIN' "$FINAL_MANIFEST" | grep 'android:name=' | head -1 | sed 's/.*android:name="//;s/".*//')
            echo "- MAIN 액티비티: $MAIN_ACTIVITY"
          else
            echo "❌ MAIN 액티비티 없음 - 앱 실행 불가"
          fi
        fi
        
        # 파일 무결성 검증
        echo "🔐 파일 무결성 검증..."
        unzip -t "$APK_TO_TEST" >/dev/null 2>&1
        if [ $? -eq 0 ]; then
          echo "✅ APK 파일 무결성 양호"
        else
          echo "❌ APK 파일 손상"
          exit 1
        fi
        
        echo "🎉 최종 수정된 APK 준비 완료: $APK_TO_TEST"
        echo "📱 설치 가능한 APK 생성됨!"

    # ✅ 원본과 수정본 비교 분석
    - name: Compare original and modified APK
      if: always()
      run: |
        echo "=== 🔍 원본과 수정본 비교 분석 ==="
        
        if [ -f "${ORIGINAL_APK:-}" ] && [ -f "final_doublecheck_fixed.apk" ]; then
          echo "📊 크기 비교:"
          echo "원본: $(du -h "$ORIGINAL_APK" | cut -f1)"
          echo "수정: $(du -h "final_doublecheck_fixed.apk" | cut -f1)"
          
          # 원본 APK 분석
          echo "📦 원본 APK 분석..."
          rm -rf original_analysis
          apktool d "$ORIGINAL_APK" -o original_analysis --force >/dev/null 2>&1
          
          if [ -f "original_analysis/AndroidManifest.xml" ]; then
            ORIG_MANIFEST="original_analysis/AndroidManifest.xml"
            echo "원본 매니페스트:"
            echo "- activity: $(grep -c '<activity' "$ORIG_MANIFEST" 2>/dev/null || echo "0")개"
            echo "- receiver: $(grep -c '<receiver' "$ORIG_MANIFEST" 2>/dev/null || echo "0")개"
            echo "- service: $(grep -c '<service' "$ORIG_MANIFEST" 2>/dev/null || echo "0")개"
            
            if grep -q "AlarmReceiver" "$ORIG_MANIFEST"; then
              echo "⚠️ 원본에 이미 AlarmReceiver 존재"
            else
              echo "❌ 원본에 AlarmReceiver 없음"
            fi
          fi
          
          # 수정본과 차이점 분석
          if [ -f "final_verification/AndroidManifest.xml" ] && [ -f "original_analysis/AndroidManifest.xml" ]; then
            echo "🔄 매니페스트 차이점:"
            diff original_analysis/AndroidManifest.xml final_verification/AndroidManifest.xml | head -20 || echo "차이점 없음"
          fi
        fi

    # ✅ 압축 방식 및 설치 호환성 검증
    - name: Compression and installation compatibility verification
      run: |
        echo "=== 🔍 압축 방식 및 설치 호환성 검증 ==="
        
        APK_FILES=(
          "original_backup.apk:원본"
          "final_doublecheck_fixed.apk:수정본"
          "alternative_fixed.apk:대안"
        )
        
        for APK_INFO in "${APK_FILES[@]}"; do
          APK_FILE="${APK_INFO%:*}"
          APK_DESC="${APK_INFO#*:}"
          
          if [ -f "$APK_FILE" ]; then
            echo ""
            echo "🔬 === $APK_DESC APK ($APK_FILE) 호환성 검증 ==="
            
            # 1. 압축 방식 확인
            echo "🗜️ 압축 방식 분석:"
            file "$APK_FILE" | grep -o "compression method=[^,]*"
            
            # 2. ZIP 헤더 상세 분석
            echo "📦 ZIP 헤더 분석:"
            hexdump -C "$APK_FILE" | head -1
            
            # 3. 안드로이드 설치 시뮬레이션
            echo "📱 설치 호환성 테스트:"
            
            # 패키지 관리자 시뮬레이션
            if aapt dump badging "$APK_FILE" >/tmp/badging.txt 2>&1; then
              echo "✅ 패키지 매니저 파싱 성공"
              
              # 중요한 설치 관련 정보 추출
              echo "📋 설치 관련 정보:"
              grep "package:" /tmp/badging.txt | head -1
              grep "sdkVersion:" /tmp/badging.txt
              grep "targetSdkVersion:" /tmp/badging.txt
              grep "launchable-activity:" /tmp/badging.txt | head -1
              
            else
              echo "❌ 패키지 매니저 파싱 실패"
              head -5 /tmp/badging.txt
            fi
            
            # 4. 매니페스트 XML 파싱 테스트
            echo "📄 매니페스트 파싱 테스트:"
            if aapt dump xmltree "$APK_FILE" AndroidManifest.xml >/tmp/xmltree.txt 2>&1; then
              echo "✅ XML 파싱 성공"
              echo "주요 컴포넌트 개수:"
              grep -c "E: activity" /tmp/xmltree.txt || echo "activity: 0"
              grep -c "E: receiver" /tmp/xmltree.txt || echo "receiver: 0"
              grep -c "E: service" /tmp/xmltree.txt || echo "service: 0"
            else
              echo "❌ XML 파싱 실패"
              head -5 /tmp/xmltree.txt
            fi
            
            # 5. 서명 및 보안 검사
            echo "🔐 보안 검사:"
            if jarsigner -verify "$APK_FILE" >/dev/null 2>&1; then
              echo "✅ 서명 검증 통과"
            else
              echo "❌ 서명 검증 실패"
            fi
            
            # 6. 설치 예상 결과
            echo "🎯 설치 예상 결과:"
            if aapt dump badging "$APK_FILE" >/dev/null 2>&1 && jarsigner -verify "$APK_FILE" >/dev/null 2>&1; then
              echo "✅ 설치 가능할 것으로 예상"
            else
              echo "❌ 설치 실패 예상"
            fi
            
            echo "--- $APK_DESC APK 검증 완료 ---"
          else
            echo "⚠️ $APK_FILE 파일 없음"
          fi
        done
        
        # 최종 권장사항
        echo ""
        echo "💡 === 최종 분석 및 권장사항 ==="
        echo "1. 원본 APK는 정상 작동하는 상태"
        echo "2. apktool 리빌드 과정에서 압축 방식 변경됨"
        echo "3. 구조적으로는 문제없으나 미세한 호환성 이슈 가능"
        echo ""
        echo "🛠️ 해결 방안:"
        echo "A. 현재 워크플로우: 압축 방식 최적화 적용"
        echo "B. 대안 방법: buildozer.spec에서 직접 권한 설정"
        echo "C. 앱 코드 방법: 런타임에 동적 receiver 등록"
    - name: Advanced APK debugging and validation
      run: |
        echo "=== 🔬 심화 APK 디버깅 및 검증 ==="
        
        APK_FILES=(
          "original_backup.apk"
          "rebuilt_doublecheck_unsigned.apk" 
          "rebuilt_doublecheck_signed.apk"
          "final_doublecheck_fixed.apk"
        )
        
        for APK_FILE in "${APK_FILES[@]}"; do
          if [ -f "$APK_FILE" ]; then
            echo ""
            echo "🔍 === $APK_FILE 분석 ==="
            
            # 1. 기본 정보
            echo "📊 파일 크기: $(du -h "$APK_FILE" | cut -f1)"
            echo "📊 파일 타입: $(file "$APK_FILE")"
            
            # 2. ZIP 구조 검증
            echo "📦 ZIP 구조 검증:"
            if unzip -t "$APK_FILE" >/dev/null 2>&1; then
              echo "✅ ZIP 구조 유효"
            else
              echo "❌ ZIP 구조 손상"
              continue
            fi
            
            # 3. APK 내부 파일 목록
            echo "📂 APK 내부 주요 파일:"
            unzip -l "$APK_FILE" | grep -E "(AndroidManifest.xml|classes.dex|META-INF/|resources.arsc)" | head -10
            
            # 4. 매니페스트 파싱 테스트
            echo "📄 매니페스트 파싱 테스트:"
            if aapt dump xmltree "$APK_FILE" AndroidManifest.xml >/dev/null 2>&1; then
              echo "✅ 매니페스트 파싱 가능"
            else
              echo "❌ 매니페스트 파싱 실패"
              aapt dump xmltree "$APK_FILE" AndroidManifest.xml 2>&1 | head -5
            fi
            
            # 5. 서명 정보 상세 분석
            echo "🔏 서명 정보 분석:"
            if jarsigner -verify -verbose "$APK_FILE" >/dev/null 2>&1; then
              echo "✅ 서명 유효"
              echo "서명 세부정보:"
              jarsigner -verify -verbose "$APK_FILE" 2>&1 | grep -E "(certificate|algorithm)" | head -3
            else
              echo "❌ 서명 무효 또는 없음"
              jarsigner -verify -verbose "$APK_FILE" 2>&1 | head -3
            fi
            
            # 6. zipalign 상태 확인
            ZIPALIGN_PATH="$HOME/android-sdk/build-tools/34.0.0/zipalign"
            if [ -f "$ZIPALIGN_PATH" ]; then
              echo "🔧 zipalign 상태:"
              if $ZIPALIGN_PATH -c 4 "$APK_FILE" >/dev/null 2>&1; then
                echo "✅ 올바르게 정렬됨"
              else
                echo "❌ 정렬되지 않음"
              fi
            fi
            
            # 7. 패키지 정보 확인
            echo "📦 패키지 정보:"
            aapt dump badging "$APK_FILE" 2>/dev/null | grep -E "(package:|application:|launchable-activity:)" | head -3
            
            # 8. 권한 확인
            echo "🔑 권한 개수: $(aapt dump permissions "$APK_FILE" 2>/dev/null | grep -c "uses-permission" || echo "0")"
            
            # 9. dex 파일 확인
            echo "⚙️ DEX 파일:"
            unzip -l "$APK_FILE" | grep "\.dex" | wc -l | xargs echo "DEX 파일 개수:"
            
            # 10. 네이티브 라이브러리 확인
            echo "📚 네이티브 라이브러리:"
            NATIVE_COUNT=$(unzip -l "$APK_FILE" | grep "lib/" | wc -l)
            echo "네이티브 라이브러리 파일 개수: $NATIVE_COUNT"
            if [ "$NATIVE_COUNT" -gt 0 ]; then
              unzip -l "$APK_FILE" | grep "lib/" | head -5
            fi
            
            echo "--- $APK_FILE 분석 완료 ---"
          else
            echo "⚠️ $APK_FILE 파일 없음"
          fi
        done

    # ✅ 매니페스트 상세 비교
    - name: Detailed manifest comparison
      run: |
        echo "=== 📋 매니페스트 상세 비교 ==="
        
        # 각 APK에서 매니페스트 추출
        APK_FILES=(
          "original_backup.apk:original"
          "final_doublecheck_fixed.apk:final"
        )
        
        for APK_INFO in "${APK_FILES[@]}"; do
          APK_FILE="${APK_INFO%:*}"
          PREFIX="${APK_INFO#*:}"
          
          if [ -f "$APK_FILE" ]; then
            echo "📄 $APK_FILE 매니페스트 추출..."
            
            # aapt로 읽기 가능한 형태로 추출
            aapt dump xmltree "$APK_FILE" AndroidManifest.xml > "${PREFIX}_manifest_readable.xml" 2>/dev/null || echo "❌ 추출 실패"
            
            # apktool로 소스 형태로 추출
            rm -rf "${PREFIX}_decode"
            apktool d "$APK_FILE" -o "${PREFIX}_decode" --force >/dev/null 2>&1
            if [ -f "${PREFIX}_decode/AndroidManifest.xml" ]; then
              cp "${PREFIX}_decode/AndroidManifest.xml" "${PREFIX}_manifest_source.xml"
              echo "✅ ${PREFIX} 매니페스트 추출 완료"
            fi
          fi
        done
        
        # 매니페스트 비교
        if [ -f "original_manifest_source.xml" ] && [ -f "final_manifest_source.xml" ]; then
          echo "🔄 매니페스트 차이점 분석:"
          diff original_manifest_source.xml final_manifest_source.xml > manifest_diff.txt || true
          
          if [ -s manifest_diff.txt ]; then
            echo "발견된 차이점:"
            head -30 manifest_diff.txt
          else
            echo "매니페스트 차이점 없음"
          fi
        fi
        
        # receiver 부분만 추출해서 비교
        for PREFIX in original final; do
          if [ -f "${PREFIX}_manifest_source.xml" ]; then
            echo "📡 ${PREFIX} APK의 receiver 목록:"
            grep -A 10 -B 2 '<receiver' "${PREFIX}_manifest_source.xml" || echo "receiver 없음"
          fi
        done

    # ✅ APK 바이너리 레벨 분석
    - name: APK binary level analysis
      run: |
        echo "=== 🔬 APK 바이너리 레벨 분석 ==="
        
        # original과 final APK 비교
        if [ -f "original_backup.apk" ] && [ -f "final_doublecheck_fixed.apk" ]; then
          echo "📊 파일 크기 비교:"
          echo "Original: $(stat -c%s original_backup.apk) bytes"
          echo "Final:    $(stat -c%s final_doublecheck_fixed.apk) bytes"
          
          # ZIP 엔트리 개수 비교
          echo "📦 ZIP 엔트리 개수:"
          echo "Original: $(unzip -l original_backup.apk | grep -c "^[ ]*[0-9]")"
          echo "Final:    $(unzip -l final_doublecheck_fixed.apk | grep -c "^[ ]*[0-9]")"
          
          # 매니페스트 바이너리 크기 비교
          echo "📄 AndroidManifest.xml 크기:"
          unzip -l original_backup.apk | grep "AndroidManifest.xml"
          unzip -l final_doublecheck_fixed.apk | grep "AndroidManifest.xml"
          
          # META-INF 비교
          echo "🔏 META-INF 디렉토리 내용:"
          echo "Original META-INF:"
          unzip -l original_backup.apk | grep "META-INF" || echo "META-INF 없음"
          echo "Final META-INF:"
          unzip -l final_doublecheck_fixed.apk | grep "META-INF" || echo "META-INF 없음"
          
          # 첫 32바이트 비교 (ZIP 헤더)
          echo "🔍 ZIP 헤더 비교:"
          echo "Original 첫 32바이트:"
          hexdump -C original_backup.apk | head -2
          echo "Final 첫 32바이트:"
          hexdump -C final_doublecheck_fixed.apk | head -2
        fi

    # ✅ 호환성 검사
    - name: Compatibility check
      run: |
        echo "=== 🔧 호환성 검사 ==="
        
        APK_FILE="final_doublecheck_fixed.apk"
        
        if [ -f "$APK_FILE" ]; then
          echo "📱 Android 호환성 검사..."
          
          # 1. 최소 SDK 버전 확인
          echo "🎯 SDK 버전 정보:"
          aapt dump badging "$APK_FILE" 2>/dev/null | grep -E "(sdkVersion|targetSdkVersion)" || echo "SDK 버전 정보 없음"
          
          # 2. 아키텍처 지원 확인
          echo "🏗️ 아키텍처 지원:"
          aapt dump configurations "$APK_FILE" 2>/dev/null | head -10 || echo "구성 정보 없음"
          
          # 3. 필수 기능 확인
          echo "⚙️ 필수 기능:"
          aapt dump badging "$APK_FILE" 2>/dev/null | grep "uses-feature" | head -5 || echo "필수 기능 없음"
          
          # 4. 화면 지원 확인
          echo "📺 화면 지원:"
          aapt dump badging "$APK_FILE" 2>/dev/null | grep "supports-screens" || echo "화면 지원 정보 없음"
          
          # 5. 매니페스트 필수 요소 확인
          echo "✅ 필수 요소 체크리스트:"
          
          # 패키지명 확인
          if aapt dump badging "$APK_FILE" 2>/dev/null | grep -q "package:"; then
            echo "✅ 패키지명 존재"
          else
            echo "❌ 패키지명 없음"
          fi
          
          # 메인 액티비티 확인
          if aapt dump badging "$APK_FILE" 2>/dev/null | grep -q "launchable-activity:"; then
            echo "✅ 실행 가능한 액티비티 존재"
          else
            echo "❌ 실행 가능한 액티비티 없음"
          fi
          
          # 애플리케이션 태그 확인
          if aapt dump badging "$APK_FILE" 2>/dev/null | grep -q "application:"; then
            echo "✅ 애플리케이션 태그 존재"
          else
            echo "❌ 애플리케이션 태그 없음"
          fi
          
          # 6. 매니페스트 XML 유효성 재검증
          echo "📋 매니페스트 XML 구조 재검증:"
          if aapt dump xmltree "$APK_FILE" AndroidManifest.xml >/tmp/manifest_dump.txt 2>&1; then
            echo "✅ XML 구조 유효"
            echo "매니페스트 주요 태그 개수:"
            grep -c "E: application" /tmp/manifest_dump.txt || echo "application: 0"
            grep -c "E: activity" /tmp/manifest_dump.txt || echo "activity: 0"
            grep -c "E: receiver" /tmp/manifest_dump.txt || echo "receiver: 0"
            grep -c "E: uses-permission" /tmp/manifest_dump.txt || echo "uses-permission: 0"
          else
            echo "❌ XML 구조 오류"
            head -10 /tmp/manifest_dump.txt
          fi
        fi
        
        echo "🎉 호환성 검사 완료!"

    # ✅ 빌드 로그 업로드
    - name: Upload build logs
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: build-logs-${{ github.run_number }}
        path: |
          build_full.log
          apk_info.txt
          manifest_diff.txt
          original_manifest_*.xml
          final_manifest_*.xml
          .buildozer/**/*.log
          original_analysis/AndroidManifest.xml
          final_verification/AndroidManifest.xml
          decoded_apk_clean/AndroidManifest.xml.backup
        retention-days: 30
        if-no-files-found: warn

    # ✅ 최종 APK 업로드
    - name: Upload final APKs
      uses: actions/upload-artifact@v4
      with:
        name: doublecheck-apks-${{ github.run_number }}
        path: |
          final_doublecheck_fixed.apk
          original_backup.apk
          rebuilt_doublecheck_unsigned.apk
          rebuilt_doublecheck_signed.apk
        retention-days: 7
        if-no-files-found: error
